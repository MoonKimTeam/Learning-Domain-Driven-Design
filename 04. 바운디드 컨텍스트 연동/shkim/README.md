# 바운디드 컨텍스트 연동

바운디드 컨텍스트 패턴은 유비쿼터스 언어의 일관성을 유지할 뿐만 아니라 모델링도 가능하게 합니다.  
모델의 목적, 즉 경계를 명시하지 않고는 모델을 구축할 수 없습니다.  
경계가 언어의 책임을 구분 짓는다면, 하나의 바운디드 컨텍스트 내의 언어는 특정 문제를 해결하는 비즈니스 도메인을 모델링합니다.  
다른 바운디드 컨텍스트가 동일한 비즈니스 엔티티(business entity)를 대표할 수 있지만, 이는 다른 문제를 해결하는 비즈니스 도메인을 모델링합니다.

한편 다른 바운디드 컨텍스트의 모델은 서로 독립적으로 발전하고 구현될 수 있습니다.  
그러나 바운디드 컨텍스트 자체는 독립적이지 않습니다. 시스템의 요소가 독립적으로 구성될 수 없습니다.  
다시 말해, 시스템의 요소가 전체의 목적을 이루기 위해 상호작용해야 하듯이, 바운디드 컨텍스트의 구현도 마찬가지로 서로 독립적으로 발전할 수 있지만 상호작용해야 합니다.

결국, 바운디드 컨텍스트 사이에는 항상 접점이 있는데 이것을 **컨트랙트(contract)** 라고 부릅니다.

컨트랙트의 필요성은 바운디드 컨텍스트의 모델과 언어의 차이에서 비롯됩니다.  
각 컨트랙트는 하나 이상의 당사자에게 영향을 미치므로 서로 조율해서 컨트랙트를 정의해야 합니다.  
또한 정의에 따르면, 바운디드 컨텍스트가 다르면 사용하는 유비쿼터스 언어도 다릅니다.  
그렇다면 연동이 필요한 경우에는 어떤 언어를 사용해야 할까요?

이번 장에서는 바운디드 컨텍스트 간의 관계와 연동을 정의하는 도메인 주도 설계 패턴에 대해 알아봅니다.  
이러한 패턴은 바운디드 컨텍스트에서 작업하는 팀 간의 협력의 특성에 의해 주도되며, 각 패턴은 **협력**, **사용자-제공자**, 그리고 **분리형 노선**의 세 그룹으로 나뉘어 살펴봅니다.

## 협력형 패턴 그룹

협력형(cooperation) 그룹의 패턴은 소통이 잘 되는 팀에서 구현한 바운디드 컨텍스트를 위한 것입니다.

팀들은 서로 다른 바운디드 컨텍스트에서 작업하지만 상호 의존하기 때문에 양방향으로 소통해야 합니다.  
서로의 요구를 수용하고, 한 팀이 다른 팀의 바운디드 컨텍스트에 영향을 미치면 다른 팀을 방해하지 않도록 적절히 알려줍니다.  
이 그룹은 두 가지 패턴을 포함합니다.

### 파트너십 패턴

파트너십(partnership) 모델에서 바운디드 컨텍스트의 연동은 특별한(ad-hoc) 방식으로 조율됩니다.

한 팀은 다른 팀에 통보하고 다른 팀은 API의 변경에 협력합니다.  
양측 모두의 요구에 맞도록 연동 컨트랙트를 공동으로 발전시킵니다.  
어느 팀도 상대 팀에 종속되지 않습니다.

### 공유 커널 패턴

공유 커널(shared kernel)은 두 개 이상의 바운디드 컨텍스트 모델의 경계에서 동시에 여러 바운디드 컨텍스트에 속하는 모델의 일부를 포함합니다.

공유 커널의 경계는 유비쿼터스 언어의 일부인 공유되는 데이터 모델입니다.  
공유 범위에는 바운디드 컨텍스트의 모델에서 상호작용하는 것은 무엇이든 포함될 수 있습니다 - 네임스페이스, 도메인 엔티티, 밸류 오브젝트.  
공유 모델의 유형이나 테스트와 같은 인프라도 포함될 수 있습니다.

공유 커널은 여러 바운디드 컨텍스트에 속하기 때문에 변경은 지속적으로 통합해야 합니다.
공유의 변경사항을 관련된 모든 바운디드 컨텍스트에 전파하지 않으면 모델의 일관성이 영향받기 때문입니다.
바운디드 컨텍스트가 변경 전의 공유 커널 구현을 참조하면 데이터 불일치나 런타임 오류가 발생할 수 있습니다.

### 공유 커널을 사용해야 하는 경우

공유 커널 패턴의 적용 여부를 결정하는 가장 중요한 기준은 **중복 비용과 조율 비용의 비율**입니다.  
이 패턴을 적용하면 바운디드 컨텍스트 간에 강한 의존관계를 만들기 때문에 중복 비용이 조율 비용보다 클 경우에만 적용해야 합니다.  
다시 말해, 두 바운디드 컨텍스트가 공유하는 코드에서의 변경을 조율하는 노력보다 공유하는 모델에 대한 변경을 통합할 때 드는 노력이 더 적을 경우에 적용합니다.

통합 비용과 중복 비용의 차이는 모델의 변동성(volatility)에 달렸습니다.
변경이 잦을수록 통합 비용은 높아지고, 그러므로 상당한 규모의 공유 커널은 핵심 하위 도메인처럼 자주 변하는 하위 도메인을 위한 것이 아닙니다.

이런 의미에서 보면, 공유 커널 패턴은 바운디드 컨텍스트의 원칙에 위배됩니다.
같은 팀이 공유 커널을 구현하지 않는다면 이는 단일 팀 원칙을 위반하는 것입니다. 공유 커널은 결과적으로 여러 팀이 함께 구현하고 유지보수해야 하기 때문입니다.

이러한 이유로 공유 커널을 사용하는 데는 명분이 필요하며, 이것은 신중하게 고려해야 하는 설계 의사결정입니다.  
일반적으로 공유 커널을 구현하는 적용 사례는 예를 들어 지리적 제약이나 조직의 정치적 문제로 커뮤니케이션이 어려워 파트너십 패턴을 구현하는 것이 비효율적일 때입니다.

공유 커널 패턴을 적용하는 또 다른 일반적인 적용 사례는 일시적이기는 하지만, 레거시 시스템을 점진적으로 현대화하려는 경우입니다.  
새 시스템에서 서서히 바운디드 컨텍스트로 분리하고 기존 코드베이스로 만드는 모델의 중간 과정이 될 수 있습니다.

## 사용자-제공자 패턴 그룹

협력 사례와 달리 이 그룹은 **사용자-제공자(customer-supplier)** 패턴 그룹이라고 합니다.

서비스 제공자는 **업스트림(upstream)** 이며, 사용자는 **다운스트림(downstream)** 입니다.

여기서 중요한 점은 업스트림과 다운스트림이라는 용어가 변경의 전파 방향이 아니라 힘의 균형을 설명한다는 것입니다.
업스트림이 다운스트림의 요구를 얼마나 수용하느냐에 따라 바운디드 컨텍스트 간 연동의 힘의 균형이 결정됩니다.

### 순응주의자 패턴

힘의 균형이 업스트림 팀에 있는 사용자-제공자 관계에서 업스트림 팀이 다운스트림 팀의 요구를 해결해주려는 의지가 없을 때 다운스트림은 업스트림 팀의 모델에 **순응(conformist)** 해야 합니다.
업스트림 팀이 노출한 컨트랙트가 다운스트림 팀의 요구에 맞지 않더라도 모델 변경을 원하지 않으면, 다운스트림은 그대로 순응하거나 자체적으로 변환 계층을 구현해야 합니다.
다운스트림의 바운디드 컨텍스트가 핵심 하위 도메인을 포함하지 않을 때 순응주의자 패턴이 적합합니다.

### 충돌 방지 계층 패턴

순응주의자 패턴에서와 마찬가지로 힘의 균형은 업스트림 서비스에 있습니다.  
그러나 이 경우 다운스트림 바운디드 컨텍스트는 업스트림 바운디드 컨텍스트의 모델을 따르지 않습니다.  
대신 **충돌 방지 계층(ACL: anticorruption layer)** 패턴은 다른 서비스와 연동할 때 외부 모델을 변환합니다.

업스트림 모델에 어떤 변경이 발생하더라도 모델 변경으로 인해 충돌 방지 계층만 영향받는 것으로 제한됩니다.  
충돌 방지 계층의 변환 메커니즘을 적용하면 다운스트림 컨텍스트의 모델은 어떤 수정 없이도 그대로 유지됩니다.

다운스트림의 바운디드 컨텍스트에 핵심 하위 도메인이 포함된 경우처럼 다운스트림의 모델을 보호하기 위해 업스트림 모델과의 연동에서 충돌 방지 계층을 사용하면 유용합니다.

## 오픈 호스트 서비스 패턴

이 패턴은 한층 더 나아가 수많은 경우를 지원합니다.  
제공자는 사용자를 보호하기 위해 기능적인 편의 제공과 함께 API를 편리하게 사용자에게 공개합니다.

제공자의 공개된 사용을 보호하기 위해 업스트림의 외부 인터페이스와 자체의 모델을 분리하고 자체적으로 유지합니다.  
분리를 통해 업스트림의 바운디드 컨텍스트를 수정하면서도 외부의 공개된 API에는 영향이 없습니다.

제공자의 서비스 컨텍스트 인터페이스는 자신의 유비쿼터스 언어를 따르는 대신, **연동 지향 언어(integration-oriented language)** 를 통해 사용자에게 더 편리한 인터페이스를 제공합니다.  
이 공개 프로토콜을 **공개된 언어(published language)** 라고 합니다.

**오픈 호스트 서비스(OHS: open-host service)** 패턴은 솔루션 및 연동 관련 기술 용어를 사용합니다.  

또한 업스트림은 자체 모델을 자유롭게 진화시킬 수 있습니다.
공개된 언어의 새로운 버전이 출시되면 기존 버전에서 새 버전으로 점진적으로 이관할 수 있습니다.

## 분리형 노선

협력이 항상 최선의 선택인 것은 아닙니다. 어떤 협력 방안도 없이 각자의 길을 가는 것이 **분리형 노선(separate ways)** 패턴입니다.
커뮤니케이션 이슈나 일반 하위 도메인의 특성이 이 패턴을 선택하는 원인이 될 수 있습니다.

### 커뮤니케이션 이슈

조직의 규모나 팀별 정치적 요인으로 인해 팀 간 효과적인 협력이 어려워지거나 불가능해지는 경우가 있습니다.
이런 상황에서는 협력의 비용이 이점을 초과하므로 분리형 노선 패턴을 선택할 수 있습니다.

### 일반 하위 도메인

일반 하위 도메인은 기성 솔루션을 손쉽게 구매하거나 구현할 수 있는 특성이 있습니다.
이 경우 동일한 기능을 각 팀에서 중복 구현하는 것이 합리적일 수 있습니다.
팀 간 충돌이 없고, 중복으로 인한 비용이 의사소통 비용보다 적다면 이러한 중복은 정당화됩니다.

### 모델의 차이

때로는 바운디드 컨텍스트 간의 모델 차이가 너무 커서 협업이 불필요한 경우도 있습니다.
이 경우 모델의 불일치가 없으므로 중복의 개념 자체가 존재하지 않습니다.
하나가 다른 것의 사본이 아니며, 각각 고유한 관점과 목적을 가진 별도의 모델입니다.
만약 두 모델이 '중복'처럼 보인다면, 그 차이점을 더 세밀하게 살펴볼 필요가 있습니다.

## 컨텍스트 맵

시스템의 바운디드 컨텍스트와 컨텍스트 간의 연동 패턴을 분석하면 **컨텍스트 맵** 그래프를 그릴 수 있습니다.

컨텍스트 맵은 시스템의 바운디드 컨텍스트 연동을 시각적으로 표현한 것입니다.
높은 수준에서 전체적인 연동 구조를 조감할 수 있는 그래프입니다.

### 기술 및 참여 관점

전사적인 팀이 사용하는 구성요소나 구현하는 것뿐만 아니라, 외부의 바운디드 시스템의 제공자도 컨텍스트 맵에 포함되어야 합니다.

### 커뮤니케이션 패턴

컨텍스트 맵은 시스템의 구성요소 간 커뮤니케이션 패턴을 시각화합니다.
시스템이 팀의 성장과 함께 변화함에 따라 컨텍스트 맵도 갱신해야 합니다.
이를 통해 기존 팀과 새로운 팀 모두 높은 수준에서 아키텍처와 커뮤니케이션 패턴을 이해할 수 있습니다.

### 조직 이슈

컨텍스트 맵은 조직의 잠재적 문제를 식별하고 해결하는 데 활용됩니다.
바운디드 컨텍스트 간의 관계와 협력 패턴에 관한 정보를 통해 적절한 의사결정을 내릴 수 있습니다.

### 유지보수

컨텍스트 맵은 조직과 시스템이 발전함에 따라 지속적으로 유지보수해야 합니다.
대형 조직에서는 **컨텍스트 매퍼(Context Mapper)** 와 같은 도구를 사용하여 컨텍스트 맵을 체계적으로 관리할 수 있습니다.

### 한계

컨텍스트 맵은 특정 구현 세부사항을 명시하지 않습니다. 어떤 모델을 사용하는지, 동기 통신인지 비동기 통신인지, 어떤 연동 기술을 사용하는지는 컨텍스트 맵에 나타나지 않습니다.
컨텍스트 맵의 패턴은 바운디드 컨텍스트 간의 관계만을 다룹니다.

또한 컨텍스트 맵만으로는 바운디드 컨텍스트가 단일 하위 도메인에 국한되어 있는지, 아니면 여러 하위 도메인을 포함하는지 알 수 없습니다.

## 결론

바운디드 컨텍스트는 서로 독립하지 않습니다. 서로 상호작용해야 하며, 다음의 패턴은 다양한 방법을 정의합니다.

| 그룹 | 패턴 | 설명 |
|---|---|---|
| 협력 | 파트너십 | 바운디드 컨텍스트에서 작업하는 팀들이 공존하여 연동 컨트랙트를 공동으로 발전시킵니다 |
| 협력 | 공유 커널 | 여러 팀들이 오버래핑되는 공유 커널을 공동으로 관리합니다 |
| 사용자-제공자 | 순응주의자 | 다운스트림 팀이 업스트림 모델을 그대로 따릅니다 |
| 사용자-제공자 | 충돌 방지 계층 | 다운스트림 팀이 변환 계층으로 업스트림 바운디드 컨텍스트 모델에서 자사의 모델을 보호합니다 |
| 사용자-제공자 | 오픈 호스트 서비스 | 제공자가 여러 사용자를 위해 공개된 언어로 API를 제공합니다 |
| 분리형 노선 | 분리형 노선 | 바운디드 컨텍스트 간 협력 없이 각자의 솔루션을 구현합니다 |

컨텍스트 맵은 시스템의 바운디드 컨텍스트와 연동을 그래프로 표현합니다.
다이어그램을 통해 높은 수준의 설계 및 커뮤니케이션 패턴에 대한 인사이트를 제공합니다.
