# 간단한 비즈니스 로직 구현

비즈니스 로직은 소프트웨어에서 가장 중요한 부분이며 애초에 소프트웨어를 구현하는 이유입니다.
모든 소프트웨어는 어떤 형태의 비즈니스 로직을 구현하기 위해 존재합니다.
시스템의 사용자 인터페이스와 애플리케이션 계층을 포함한 바운디드 컨텍스트는 다양한 형태의 비즈니스 로직을 가지고 있으며, 비즈니스 로직이 비즈니스 정책과 의사결정의 중요성을 결정합니다.

## 트랜잭션 스크립트

> "어떤 비즈니스 트랜잭션을 단일 프로시저로 구성합니다. 각 트랜잭션은 자체 트랜잭션 스크립트를 갖고 공통 하위 작업은 하위 프로시저로 분류할 수 있습니다."  
> — 마틴 파울러(Martin Fowler)

시스템의 퍼블릭 인터페이스는 간단한 1대1 구조이고 사용자가 실행할 수 있는 비즈니스 트랜잭션 집합을 제공합니다.  
제공된 비즈니스 인터페이스를 통해 시스템 사용자가 실행하는 연산은 구현합니다.  
이 개념이 바로 **트랜잭션 스크립트 패턴**이고 오퍼레이션은 **트랜잭션**의 경계로 사용합니다.

### 구현

프로시저는 간단하여 이른 절차지향 스크립트(procedural script)로 구현합니다. 저장 장치를 직접 사용하거나 추상화된 레이어를 대리자로 사용하여 데이터베이스에 직접 접근하는 코드를 가지고 있습니다.

조금 더 발전시키면 데이터 접근을 레이어를 통해 추상화할 수도 있습니다.  
예를 들어 JSON 파일이라든가 XML 파일로 변환하는 트랜잭션 스크립트의 예시입니다.

```cs
public void Execute(Guid userId, DateTime visitedOn)
{
    _db.StartTransaction();

    _db.Execute("UPDATE Users SET last_visit=@p1 WHERE user_id=@p2",
        visitedOn, userId);
}
```

## 분산 트랜잭션

분산 트랜잭션은 여러 데이터베이스의 데이터를 연결한 다른 메시지 버스에 메시지를 발행해야 한다면, 이 작업들의 트랜잭션을 분산합니다.   

```csharp
public class LogVisit
{
    public void Execute(Guid userId, DateTime visitedOn)
    {
        _db.Execute("UPDATE Users SET last_visit=@p1 WHERE user_id=@p2",
            visitedOn, userId);

        _messageBus.Publish("VISITS_TOPIC",
            new { UserId = userId, VisitDate = visitedOn });
    }
}
```

앞의 예시에서 두 작업 중 하나가 실패하면 시스템의 상태가 일관성 없게 됩니다. 데이터베이스에는 저장됐지만 메시지는 발행되지 않거나, 그 반대의 상황이 발생할 수 있습니다.
분산 트랜잭션으로 이를 해결하려면 복잡하고 오류가 발생하기 쉬우며 확장성 문제가 있습니다.


### 암시적 분산 트랜잭션

같은 데이터 저장소 내에서도 암시적 분산 트랜잭션 문제가 발생할 수 있습니다.
이 경우 낙관적 동시성 제어(optimistic concurrency control)를 통해 해결할 수 있습니다.

```csharp
public class LogVisit
{
    public void Execute(Guid userId, long expectedVisits)
    {
        _db.Execute("UPDATE Users SET visits=visits+1 SET visits=@p1+1 WHERE user_id=@p2 AND visits = @p1",
            expectedVisits, userId);
    }
}
```


## 트랜잭션 스크립트를 사용하는 경우

트랜잭션 스크립트 패턴은 비즈니스 로직이 단순한 절차적 작업처럼 매우 간단한 문제 도메인에 효과적입니다.  
예를 들어 ETL(추출-변환-적재) 작업에서 각 작업은 원천 시스템에서 데이터를 추출하고 변환 로직을 적용하여 데이터를 다른 형식으로 변환하고 결과를 목적 시스템에 적재하는 작업입니다.

트랜잭션 스크립트 패턴 정의상 비즈니스 로직이 단순한 지원 하위 도메인에 적합합니다.  
또한 외부 도메인과 같은 외부 시스템과 연동하기 위한 어댑터로 사용하거나 충돌 방지 계층의 일부로 사용할 수도 있습니다.

트랜잭션 스크립트 패턴의 주요 장점은 단순함입니다. 최소한의 추상화를 도입하여 런타임 성능도 최적화하며, 비즈니스 로직을 이해하기 위한 시간을 최소화합니다.  
이러한 단순함은 패턴의 단점이 될 수도 있습니다. 비즈니스 로직이 복잡할수록 트랜잭션 간에 비즈니스 로직이 중복되기 쉽고 결과적으로 중복된 코드가 동기화되지 않을 때 일관성 없는 동작이 발생합니다.

결과적으로 핵심 하위 도메인에는 트랜잭션 스크립트를 사용하면 안 됩니다.  
핵심 하위 도메인의 비즈니스 로직은 복잡할 경우 트랜잭션 스크립트 패턴이 대처할 수 없다는 문제가 발생할 수 있습니다.

이러한 단순함 때문에 트랜잭션 스크립트가 항상 최선은 아니며, 잘못된 상황에서 사용되면 안티 패턴으로 간주되기도 합니다.  

## 액티브 레코드

> "데이터베이스 테이블 또는 뷰의 행을 감싸는 래퍼입니다. 컬럼과 관련하여 레코드 데이터에 대한 접근을 캡슐화하고 해당 데이터에 도메인 로직을 추가한다."  
> — 마틴 파울러(Martin Fowler)

트랜잭션 스크립트 패턴과 마찬가지로 **액티브 레코드** 패턴은 비즈니스 로직이 간단한 경우 사용됩니다.  
하지만 외부 의존과 같은 데이터베이스 스키마에 매핑하는 복잡성을 해소합니다.  
두 패턴의 차이점은 액티브 레코드 경우 복잡한 자료구조를 데이터베이스 스키마에 매핑하는 복잡성을 해소합니다.

액티브 레코드 패턴은 빈약한 도메인 모델 안티패턴(anemic domain model antipattern)이라고도 하며, 다시 말하면 부적절하게 설계된 도메인 모델입니다.  
개인적으로 **'빈약한'(anemic)** 과 **'안티패턴'(antipattern)** 이라는 부정적인 표현은 쓰고 싶지 않습니다. 이 패턴은 도구입니다.  
다른 도구와 마찬가지로 문제를 해결할 수 있지만 잘못된 컨텍스트에 적용하면 잠재적으로 독이 될 수 있습니다.

비즈니스 로직이 단순할 때 액티브 레코드를 사용하는 데는 아무런 문제가 없습니다.

### 구현

액티브 레코드 객체는 관계형 매핑(relational mapping)을 통해 객체를 사용하여 복잡한 데이터 구조를 표현합니다.
액티브 레코드는 트랜잭션 스크립트와 함께 사용되어 시스템의 퍼블릭 인터페이스 요구사항을 구현합니다.

```csharp
public class CreateUser
{
    public void Execute(UserDetails userDetails)
    {
        _db.StartTransaction();

        var user = new User();
        user.Name = userDetails.Name;
        user.Email = userDetails.Email;
        user.DoB = userDetails.DoB;
        // ...

        _db.Commit();
    }
}
```

이 패턴의 핵심은 복잡한 데이터 구조와 데이터베이스 스키마 간의 매핑 복잡성을 숨기는 것입니다. 이를 통해 트랜잭션 스크립트가 비즈니스 로직에 집중할 수 있도록 해줍니다.

## 실용적인 접근 방식

비록 비즈니스 데이터가 중요하고 설계 및 개발하는 코드의 무결성도 보호해야 하지만, 실용적인 접근 방식이 바람직한 몇 가지 경우가 있습니다.

특히 대규모 데이터를 다루는 시스템에서는 데이터의 일관성 보장이 덜 엄격할 수 있습니다.  
예를 들어, 100만 개 중 하나의 레코드 상태가 손상되는 것이 실제로 비즈니스에 치명적인지를 고민해봐야 합니다.
